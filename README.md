# Решение контеста на Java

Не нашел полноценного набора решений к этому показательному контесту на Java, поэтому решил поделиться своими впечатлениями и решениями. Возможно, это будет полезно другим.

## Общие впечатления:

Контест длится 2,5 часа. Учитывая, что задач всего шесть (и первая — ознакомительная), по полчаса на каждую задачу кажется вполне разумным. Однако, задачи не равноценны: они идут от простых к сложным. Это стало для меня проблемой — на первых задачах я потратил слишком много времени на "украшательства", что аукнулось позже.

Из неприятного: при тестировании, если какое-то решение падает, система не дает подробностей — видно только тип ошибки. А ошибка WA (Wrong Answer) ставит в тупик, так как примеров входных данных попросту нет.

## Описание задач и решений:

### 1. **A. Камни и украшения [Тестовая задача]**

Задача крайне простая — ознакомительная. Знакомимся с типом взаимодействия в контесте. Я просто скопировал решение с Java и пошел дальше.

### 2. **B. Последовательно идущие единицы**

Задача простая, не стоит бояться терминов вроде "бинарный вектор". Для меня это была настоящая тестовая задача.

На этом этапе я столкнулся с первыми проблемами:

- Импорты нужно писать самому.
- В первой строке передается количество строк, которые мы получим на выходе. Я потратил прилично времени, пытаясь понять, почему получаю WA. Оказалось, первая строка воспринималась мной как часть данных.
- В итоге я просто проигнорировал первую строку, так как она не несет смысла. Считываю через `lines()`, что работает успешно.
  
Понимаю, что для оптимального использования памяти считывать все строки сразу не лучшая идея, но на данном этапе это не критично.

### 3. **C. Удаление дубликатов**

Тоже достаточно простая задача. В первой версии решения я собирал все данные в `Set`, что приводило к падению на больших тестах из-за нехватки памяти.

Обратил внимание на условие: "дан упорядоченный по неубыванию массив целых 32-разрядных чисел". Это позволило мне обходить дубликаты, просто пропуская повторяющиеся элементы, и проблема с памятью была решена.

### 4. **D. Генерация скобочных последовательностей**

Эта задача была уже сложнее. Мое решение через рекурсию отлично работало на примерах, но падало на скрытых тестах из-за недостатка памяти.

Потратив много времени на попытки оптимизировать решение, я наткнулся на совет использовать чтение и запись через файлы. Это значительно сократило использование памяти.

Создал шаблон, где в метод `run()` передавал само решение для всех последующих задач. Но, к сожалению, из-за потраченного времени я не успел сдать задачу в контесте.

### 5. **E. Анаграммы**

На мой взгляд, эта задача была проще предыдущей. Подобную я уже решал на LeetCode, так что решил потешить самолюбие и реализовать решение с использованием бинарных операторов (маски). Это крайне эффективно как по памяти, так и по времени.

Однако, если бы был ограничен во времени, использовал бы стандартный метод через сортировки.

### 6. **G. Интересное путешествие**

Самая сложная задача в контесте, на мой взгляд. Я пытался решить ее через матрицы, сортировки и другие методы, но безуспешно.

В конце концов, я наткнулся на графы и поиск в ширину (BFS). Написал алгоритм, который заработал с первой попытки, но падал на 15-м тесте. Без дебаггера было сложно понять, в чем ошибка. Нашел рабочее решение на Python и перенес логику на Java, но проблема осталась.

После долгих мучений, понял, что причина в переполнении `int` из-за того, что координаты городов могут быть до миллиарда. Исправил код, используя `long`, и задача начала проходить тесты, но уже с проблемами по памяти.

Вернувшись к своему первому решению, я правильно кастанул подсчет расстояний и, наконец, получил заветное "ОК".

## Эпилог

Хотя я провалил контест, это было полезным опытом. Из приятного: Java работает быстрее Python и потребляет меньше памяти при правильной настройке.

Надеюсь, кому-то эти заметки окажутся полезными и помогут сэкономить время.
